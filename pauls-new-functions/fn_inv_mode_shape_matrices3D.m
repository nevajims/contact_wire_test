function inv_mode_shapes = fn_inv_mode_shape_matrices(raw_data, proc_data, array, disperse, ms_matrix_calc_freqs, ms_matrix_modes_to_use, suppress_display);
tic;
no_time_traces = size(raw_data.time_data, 2);
no_mode_combinations_proc = length(proc_data.tx_mode);
max_mode_index = max([max(proc_data.tx_mode), max(proc_data.rx_mode)]);
node_pts = size(disperse.mode(1).ms_x,2);
inv_mode_shapes = zeros(no_mode_combinations_proc, no_time_traces, length(ms_matrix_calc_freqs));
mode_shapes = zeros(no_time_traces, no_mode_combinations_proc);
for ii=1:length(ms_matrix_calc_freqs)
	%interpolate to get mode shapes and wavenumbers of all the modes at the current frequency
	temp_mode_shape = zeros(max_mode_index, node_pts, max(max(array.trans_pos_orientations)));
    
	temp_waveno = zeros(max_mode_index, 1);
    %Need to make this x, y and z (and perhaps normal and tangential also?)
    %so that the necessary direction can be selected when building the
    %matrix below. Also, this needs to take into account the phase
    %orientation of the transducers which is not currently used??
	for jj=1:length(ms_matrix_modes_to_use)
		temp_mode_shape(ms_matrix_modes_to_use(jj),:,1) = interp1( ...
			disperse.mode(ms_matrix_modes_to_use(jj)).freq, ...
			disperse.mode(ms_matrix_modes_to_use(jj)).ms_x, ...
			ms_matrix_calc_freqs(ii),'PCHIP');  
		temp_mode_shape(ms_matrix_modes_to_use(jj),:,2) = interp1( ...
			disperse.mode(ms_matrix_modes_to_use(jj)).freq, ...
			disperse.mode(ms_matrix_modes_to_use(jj)).ms_y, ...
			ms_matrix_calc_freqs(ii),'PCHIP'); 
		temp_mode_shape(ms_matrix_modes_to_use(jj),:,3) = interp1( ...
			disperse.mode(ms_matrix_modes_to_use(jj)).freq, ...
			disperse.mode(ms_matrix_modes_to_use(jj)).ms_z, ...
			ms_matrix_calc_freqs(ii),'PCHIP'); 
		temp_waveno(ms_matrix_modes_to_use(jj)) = interp1( ...
			disperse.mode(ms_matrix_modes_to_use(jj)).freq, ...
			disperse.mode(ms_matrix_modes_to_use(jj)).waveno, ...
			ms_matrix_calc_freqs(ii),'PCHIP');
    end
	%build the mode shape matrix at this frequency, taking into account the
	%orientation of the transducers
	for jj=1:no_mode_combinations_proc
        for iii=1:no_time_traces
%             mode_shapes(iii, jj) = (...
%                 temp_mode_shape(proc_data.tx_mode(jj), array.trans_node_list(raw_data.tx_pos(iii)),array.trans_pos_orientations(raw_data.tx_row(iii),raw_data.tx_pos(iii))) .* ...
%                 temp_mode_shape(proc_data.rx_mode(jj), array.trans_node_list(raw_data.rx_pos(iii)),array.trans_pos_orientations(raw_data.rx_row(iii),raw_data.rx_pos(iii))) .* ...
%                 exp( 1i*temp_waveno(proc_data.tx_mode(jj)) * array.row_pos(raw_data.tx_row(iii)) * proc_data.tx_dir(jj)).* ...
%                 exp( 1i*temp_waveno(proc_data.rx_mode(jj)) * array.row_pos(raw_data.rx_row(iii)) * proc_data.rx_dir(jj)) * ...
%                 array.trans_pos_phasings(raw_data.tx_row(iii),raw_data.tx_pos(iii)) * array.trans_pos_phasings(raw_data.rx_row(iii),raw_data.rx_pos(iii)) ...
%                 ).';
            %MJE - 8/3/21 I made a change to the first two terms to refer to
            %the node number of the tx/rx transducer position rather than just the position, not sure if I'm right here
            %Also put the orientation into the temp_mode_shape and tried to
            %link this to the array of trans orientations.
            %Also put in the sign as the actual phasings of the transducers
            %in the last row, before it was just set to 1.
            mode_shapes(iii, jj) = ...
                dot(squeeze(temp_mode_shape(proc_data.tx_mode(jj), array.trans_node_list(array.trans_pos(raw_data.tx(iii))), :)), squeeze(array.trans_pos_orientations(raw_data.tx(iii), :))) * ...
                dot(squeeze(temp_mode_shape(proc_data.rx_mode(jj), array.trans_node_list(array.trans_pos(raw_data.rx(iii))), :)), squeeze(array.trans_pos_orientations(raw_data.rx(iii), :))) * ...
                exp(1i * temp_waveno(proc_data.tx_mode(jj)) * array.row_pos(array.trans_row(raw_data.tx(iii))) * proc_data.tx_dir(jj)) * ...
                exp(1i * temp_waveno(proc_data.rx_mode(jj)) * array.row_pos(array.trans_row(raw_data.rx(iii))) * proc_data.rx_dir(jj));
        end
    end
	mode_shapes(find(isnan(mode_shapes)))=0;
	mode_shapes(find(isinf(mode_shapes)))=0;
	inv_mode_shapes(:,:,ii) = pinv(mode_shapes);
end
if ~suppress_display
	disp(['Inverse mode shape matrix built: ',num2str(toc)]);
end
return